# AOC Day 5

```elixir
Mix.install([
  {:kino, "~> 0.11.0"}
])
```

## Part 1

```elixir
input = Kino.Input.textarea("Input")
```

```elixir
text = Kino.Input.read(input)

seeds =
  text
  |> String.trim()
  |> String.split("\n\n")
  |> Enum.at(0)
  |> String.split(" ")
  |> Enum.drop(1)
  |> Enum.map(&(Integer.parse(&1) |> elem(0)))

maps =
  text
  |> String.trim()
  |> String.split("\n\n")
  |> Enum.drop(1)
  |> Enum.map(
    &(String.split(&1, "\n")
      |> Enum.drop(1)
      |> Enum.map(fn l ->
        String.split(l, " ") |> Enum.map(fn el -> Integer.parse(el) |> elem(0) end)
      end))
  )

map_fun = fn mappings, input ->
  mappings
  |> Enum.reduce_while(input, fn [deststart, srcstart, length], acc ->
    if input >= srcstart and input < srcstart + length do
      {:halt, input - srcstart + deststart}
    else
      {:cont, acc}
    end
  end)
end

seeds
|> Enum.map(fn seed ->
  maps
  |> Enum.reduce(seed, fn mapping, acc ->
    map_fun.(mapping, acc)
  end)
end)
|> Enum.min()
```

## Part 2

```elixir
text = Kino.Input.read(input)

seeds =
  text
  |> String.trim()
  |> String.split("\n\n")
  |> Enum.at(0)
  |> String.split(" ")
  |> Enum.drop(1)
  |> Enum.map(&(Integer.parse(&1) |> elem(0)))

maps =
  text
  |> String.trim()
  |> String.split("\n\n")
  |> Enum.drop(1)
  |> Enum.map(
    &(String.split(&1, "\n")
      |> Enum.drop(1)
      |> Enum.map(fn l ->
        String.split(l, " ") |> Enum.map(fn el -> Integer.parse(el) |> elem(0) end)
      end))
  )

map_fun = fn mappings, input ->
  mappings
  |> Enum.reduce_while(input, fn [deststart, srcstart, length], acc ->
    if input >= srcstart and input < srcstart + length do
      {:halt, input - srcstart + deststart}
    else
      {:cont, acc}
    end
  end)
end

map_fun_reverse = fn mappings, input ->
  mappings
  |> Enum.reduce_while(input, fn [deststart, srcstart, length], acc ->
    if input >= deststart and input < deststart + length do
      {:halt, input - deststart + srcstart}
    else
      {:cont, acc}
    end
  end)
end

test = [[20, 50, 10]]

map_fun_reverse(
  test,
  25
  |> IO.inspect()
)

# find the map-boundaries, if we had two consecutive maps
# 50..60 -> 20..30
# 25..35 -> 10..20 / 10..20 -> 70..80
# the min result is 10, with 55 as input
# how do we find it efficiently?
#
# the first map splits the input at 0-49, 50-60, 61-inf
# the second set of maps split the input at 0-9, 10-20, 21-24, 25-35, 36-inf, resulting in 5 ranges
#
# to find the lowest number, we need to combine these ranges, but how?
#
# we combine it like this:
# 1) 0-49, 50-60, 61-inf
# 2) split at 54, 55, 35, 36, 9, 10, 49, 50
# then evaluate at each splitpoint (low and high), we should then get the min/max result
# so from the back, take each input range (splits at low/high), translate each number
# using the reverse of the map, and join it with the splits of the input range of the next
# map, then proceed

seeds
|> Enum.map(fn seed ->
  maps
  |> Enum.reduce(seed, fn mapping, acc ->
    map_fun.(mapping, acc)
  end)
end)
|> Enum.min()
```
